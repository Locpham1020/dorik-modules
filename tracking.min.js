/**
 * TRACKING.MIN.JS - Analytics Tracking
 * Event tracking v·ªõi Google Apps Script v√† platform clicks
 */

(function() {
  'use strict';

  // === TRACKING MANAGER ===
  window.DorikTracking = {
    
    initialized: false,
    eventQueue: [],
    isOnline: navigator.onLine,

    // Initialize tracking system
    async init() {
      // Setup online/offline detection
      this.setupNetworkDetection();
      
      // Setup platform click tracking
      this.setupPlatformTracking();
      
      // Process any queued events
      this.processEventQueue();
      
      this.initialized = true;
      window.DorikUtils?.log('‚úÖ Tracking system initialized');
    },

    // Setup network status detection
    setupNetworkDetection() {
      window.addEventListener('online', () => {
        this.isOnline = true;
        window.DorikUtils?.log('üåê Back online - processing queued events');
        this.processEventQueue();
      });

      window.addEventListener('offline', () => {
        this.isOnline = false;
        window.DorikUtils?.log('üì¥ Offline - events will be queued');
      });
    },

    // Setup platform click tracking
    setupPlatformTracking() {
      // Use event delegation for platform links
      document.addEventListener('click', this.handlePlatformClick.bind(this));
    },

    // Handle platform clicks (Shopee, TikTok, etc.)
    handlePlatformClick(event) {
      const target = event.target;
      const link = target.closest('a[href]');
      
      if (!link) return;

      const href = link.getAttribute('href');
      if (!href) return;

      // Detect platform based on URL
      const platform = this.detectPlatform(href);
      if (!platform) return;

      // Get container ID
      const containerId = window.DorikUtils?.findContainerId(link);
      if (!containerId) return;

      // Track platform click
      this.trackEvent('platform_click', {
        container_id: containerId,
        platform: platform,
        url: href
      });

      // Update counter
      if (window.DorikState) {
        window.DorikState.counters.platformClicks++;
      }

      window.DorikUtils?.log(`üîó Platform click tracked: ${platform}`);
    },

    // Detect platform from URL
    detectPlatform(url) {
      const platformPatterns = {
        'shopee': /shopee\.(vn|com|sg|my|th|ph|tw|br|co\.id|pl)/i,
        'tiktok': /tiktok\.com|tiktokshop/i,
        'lazada': /lazada\.(vn|com|sg|my|th|ph|co\.id)/i,
        'sendo': /sendo\.vn/i,
        'tiki': /tiki\.vn/i,
        'facebook': /facebook\.com|fb\.com/i,
        'instagram': /instagram\.com/i,
        'zalo': /zalo\.me/i,
        'telegram': /t\.me|telegram/i,
        'youtube': /youtube\.com|youtu\.be/i,
        'amazon': /amazon\.(com|vn|sg|jp|uk|de|fr|it|es|ca|au|in|br|mx)/i,
        'alibaba': /alibaba\.com|aliexpress\.com/i,
        'ebay': /ebay\.(com|vn|sg|my|th|ph|tw|au|uk|de|fr|it|es|ca)/i
      };

      for (const [platform, pattern] of Object.entries(platformPatterns)) {
        if (pattern.test(url)) {
          return platform;
        }
      }

      return null;
    },

    // Main event tracking function
    async trackEvent(eventName, eventData = {}) {
      if (!this.initialized) {
        // Queue event if not initialized
        this.eventQueue.push({ eventName, eventData, timestamp: Date.now() });
        return;
      }

      try {
        // Prepare tracking data
        const trackingData = this.prepareTrackingData(eventName, eventData);
        
        // Send event
        if (this.isOnline) {
          await this.sendEvent(trackingData);
        } else {
          // Queue for later if offline
          this.eventQueue.push({ 
            eventName, 
            eventData: trackingData, 
            timestamp: Date.now() 
          });
        }

      } catch (error) {
        window.DorikUtils?.error('Tracking error:', error);
        
        // Queue event for retry
        this.eventQueue.push({ 
          eventName, 
          eventData, 
          timestamp: Date.now(),
          retryCount: (eventData.retryCount || 0) + 1
        });
      }
    },

    // Prepare tracking data with device info
    prepareTrackingData(eventName, eventData) {
      const deviceInfo = window.DorikState?.deviceInfo || window.DorikUtils?.getDeviceInfo();
      const affiliateId = window.DorikUtils?.getAffiliateId();
      
      return {
        event: eventName,
        timestamp: new Date().toISOString(),
        page_url: window.location.href,
        referrer: document.referrer || 'direct',
        affiliate_id: affiliateId,
        
        // Device information
        device_type: deviceInfo?.device || 'unknown',
        os: deviceInfo?.os || 'unknown',
        screen_width: deviceInfo?.screenWidth || window.innerWidth,
        screen_height: deviceInfo?.screenHeight || window.innerHeight,
        user_agent: deviceInfo?.userAgent || navigator.userAgent,
        connection_type: deviceInfo?.effectiveType || 'unknown',
        is_mobile: deviceInfo?.isMobile || false,
        
        // Performance info
        performance_memory: this.getMemoryInfo(),
        page_load_time: this.getPageLoadTime(),
        
        // Custom event data
        ...eventData
      };
    },

    // Send event to Google Apps Script
    async sendEvent(trackingData) {
      const config = window.DorikConfig;
      if (!config?.GOOGLE_SCRIPT_URL) {
        throw new Error('Google Script URL not configured');
      }

      const response = await fetch(config.GOOGLE_SCRIPT_URL, {
        method: 'POST',
        mode: 'cors',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(trackingData)
      });

      if (!response.ok) {
        throw new Error(`Tracking request failed: ${response.status}`);
      }

      const result = await response.json();
      window.DorikUtils?.log('‚úÖ Event tracked:', trackingData.event);
      return result;
    },

    // Process queued events
    async processEventQueue() {
      if (!this.isOnline || this.eventQueue.length === 0) {
        return;
      }

      window.DorikUtils?.log(`üì§ Processing ${this.eventQueue.length} queued events`);
      
      const eventsToProcess = [...this.eventQueue];
      this.eventQueue = [];

      for (const queuedEvent of eventsToProcess) {
        try {
          // Skip events that are too old (older than 1 hour)
          const eventAge = Date.now() - queuedEvent.timestamp;
          if (eventAge > 3600000) {
            window.DorikUtils?.log('‚è∞ Skipping old event:', queuedEvent.eventName);
            continue;
          }

          // Skip events with too many retries
          if (queuedEvent.retryCount && queuedEvent.retryCount > 3) {
            window.DorikUtils?.log('‚ùå Max retries reached:', queuedEvent.eventName);
            continue;
          }

          // Update timestamp for queued events
          if (queuedEvent.eventData) {
            queuedEvent.eventData.queued_timestamp = new Date(queuedEvent.timestamp).toISOString();
            queuedEvent.eventData.processed_timestamp = new Date().toISOString();
          }

          await this.sendEvent(queuedEvent.eventData || queuedEvent);
          
        } catch (error) {
          window.DorikUtils?.error('Failed to process queued event:', error);
          
          // Re-queue with retry count
          queuedEvent.retryCount = (queuedEvent.retryCount || 0) + 1;
          if (queuedEvent.retryCount <= 3) {
            this.eventQueue.push(queuedEvent);
          }
        }
      }
    },

    // Get memory information
    getMemoryInfo() {
      if (!performance.memory) {
        return null;
      }

      return {
        used_mb: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
        total_mb: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
        limit_mb: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
      };
    },

    // Get page load time
    getPageLoadTime() {
      if (!performance.timing) {
        return null;
      }

      const timing = performance.timing;
      return {
        dom_ready: timing.domContentLoadedEventEnd - timing.navigationStart,
        page_load: timing.loadEventEnd - timing.navigationStart,
        dns_lookup: timing.domainLookupEnd - timing.domainLookupStart,
        tcp_connect: timing.connectEnd - timing.connectStart,
        server_response: timing.responseEnd - timing.requestStart
      };
    },

    // Track page view
    trackPageView() {
      this.trackEvent('page_view', {
        title: document.title,
        pathname: window.location.pathname,
        search: window.location.search,
        hash: window.location.hash
      });
    },

    // Track scroll depth
    trackScrollDepth(depth) {
      this.trackEvent('scroll_depth', {
        depth: depth,
        max_scroll: Math.round((window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100)
      });
    },

    // Track performance metrics
    trackPerformance() {
      if (!performance.getEntriesByType) {
        return;
      }

      const navigation = performance.getEntriesByType('navigation')[0];
      if (!navigation) {
        return;
      }

      this.trackEvent('performance', {
        load_time: Math.round(navigation.loadEventEnd - navigation.loadEventStart),
        dom_ready_time: Math.round(navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart),
        dns_time: Math.round(navigation.domainLookupEnd - navigation.domainLookupStart),
        tcp_time: Math.round(navigation.connectEnd - navigation.connectStart),
        response_time: Math.round(navigation.responseEnd - navigation.responseStart),
        transfer_size: navigation.transferSize || 0,
        encoded_body_size: navigation.encodedBodySize || 0,
        decoded_body_size: navigation.decodedBodySize || 0
      });
    },

    // Track error
    trackError(error, context = '') {
      this.trackEvent('error', {
        message: error.message || String(error),
        stack: error.stack || '',
        context: context,
        user_agent: navigator.userAgent,
        url: window.location.href
      });
    },

    // Track cache performance
    trackCachePerformance() {
      const productCache = window.DorikCache?.productCache;
      const imageCache = window.DorikCache?.imageCache;
      
      if (!productCache || !imageCache) {
        return;
      }

      this.trackEvent('cache_performance', {
        product_cache: productCache.getStats(),
        image_cache: imageCache.getStats(),
        counters: window.DorikState?.counters || {}
      });
    },

    // Batch track multiple events
    async batchTrackEvents(events) {
      const batchData = {
        batch: true,
        timestamp: new Date().toISOString(),
        events: events.map(event => this.prepareTrackingData(event.name, event.data))
      };

      try {
        await this.sendEvent(batchData);
        window.DorikUtils?.log(`‚úÖ Batch tracked ${events.length} events`);
      } catch (error) {
        window.DorikUtils?.error('Batch tracking error:', error);
        // Fall back to individual tracking
        for (const event of events) {
          await this.trackEvent(event.name, event.data);
        }
      }
    },

    // Get tracking stats
    getStats() {
      return {
        initialized: this.initialized,
        isOnline: this.isOnline,
        queuedEvents: this.eventQueue.length,
        counters: window.DorikState?.counters || {}
      };
    },

    // Cleanup
    cleanup() {
      // Send final batch of events
      if (this.eventQueue.length > 0) {
        // Try to send immediately (sync)
        navigator.sendBeacon && this.sendBeaconEvents();
      }
    },

    // Send events using beacon API for cleanup
    sendBeaconEvents() {
      const config = window.DorikConfig;
      if (!config?.GOOGLE_SCRIPT_URL || this.eventQueue.length === 0) {
        return;
      }

      const batchData = {
        batch: true,
        beacon: true,
        timestamp: new Date().toISOString(),
        events: this.eventQueue.map(event => 
          event.eventData || this.prepareTrackingData(event.eventName, event.eventData)
        )
      };

      try {
        navigator.sendBeacon(
          config.GOOGLE_SCRIPT_URL,
          JSON.stringify(batchData)
        );
        window.DorikUtils?.log(`üì° Beacon sent ${this.eventQueue.length} events`);
        this.eventQueue = [];
      } catch (error) {
        window.DorikUtils?.error('Beacon send error:', error);
      }
    }
  };

  // Setup error tracking
  window.addEventListener('error', (event) => {
    if (window.DorikTracking?.trackError) {
      window.DorikTracking.trackError(event.error, 'global_error');
    }
  });

  // Setup unhandled promise rejection tracking
  window.addEventListener('unhandledrejection', (event) => {
    if (window.DorikTracking?.trackError) {
      window.DorikTracking.trackError(event.reason, 'unhandled_promise');
    }
  });

  window.DorikUtils?.log('‚úÖ Tracking module loaded');

})();
