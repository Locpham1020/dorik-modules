/**
 * FIREBASE MODULE - Firebase Integration with Retry Logic
 * URL: https://yourname.github.io/dorik-modules/firebase.min.js
 */

window.DorikFirebase = (function() {
  'use strict';

  // === FIREBASE MANAGER ===
  const FirebaseManager = {
    initialized: false,
    pendingRequests: {},
    
    // Initialize Firebase
    async init() {
      if (this.initialized) return true;
      
      try {
        // Load Firebase if not already loaded
        if (typeof firebase === 'undefined') {
          await this.loadFirebaseScripts();
        }
        
        // Get config
        const config = window.DorikConfig ? 
          window.DorikConfig.get('FIREBASE') : 
          window.firebaseConfig;
        
        if (!config) {
          throw new Error('Firebase config not found');
        }
        
        // Initialize Firebase
        if (!firebase.apps.length) {
          firebase.initializeApp(config);
        }
        
        this.initialized = true;
        this._log('Firebase initialized successfully');
        return true;
        
      } catch (error) {
        console.error('Firebase initialization failed:', error);
        return false;
      }
    },

    // Load Firebase scripts dynamically
    loadFirebaseScripts() {
      return new Promise((resolve, reject) => {
        const scripts = [
          'https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js',
          'https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js'
        ];
        
        let loadedCount = 0;
        
        scripts.forEach(src => {
          const script = document.createElement('script');
          script.src = src;
          script.async = true;
          
          script.onload = () => {
            loadedCount++;
            if (loadedCount === scripts.length) {
              resolve();
            }
          };
          
          script.onerror = () => reject(new Error(`Failed to load ${src}`));
          document.head.appendChild(script);
        });
      });
    },

    // Fetch product data with retry mechanism
    async fetchProductData(productId, attempt = 1) {
      await this.init();
      
      // Check cache first
      if (window.DorikCache && window.DorikCache.hasProduct(productId)) {
        return window.DorikCache.getProduct(productId);
      }
      
      // Return existing pending request
      if (this.pendingRequests[productId]) {
        return this.pendingRequests[productId];
      }
      
      const config = window.DorikConfig ? window.DorikConfig.get('PERFORMANCE') : {
        FIREBASE_TIMEOUT: 5000,
        FIREBASE_RETRY_ATTEMPTS: 3,
        FIREBASE_RETRY_DELAY: 1000
      };
      
      const firebasePath = productId.includes('_') 
        ? `${productId.split('_')[0]}/${productId}` 
        : productId;
      
      const request = new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          reject(new Error(`Firebase request timeout (attempt ${attempt})`));
        }, config.FIREBASE_TIMEOUT);
        
        firebase.database().ref(firebasePath)
          .once('value')
          .then(snapshot => {
            clearTimeout(timeoutId);
            const data = snapshot.val();
            
            // Cache the data
            if (data && window.DorikCache) {
              window.DorikCache.setProduct(productId, data);
              window.DorikCache.smartPreloadImages(data);
            }
            
            delete this.pendingRequests[productId];
            resolve(data);
          })
          .catch(error => {
            clearTimeout(timeoutId);
            delete this.pendingRequests[productId];
            
            // Retry logic
            if (attempt < config.FIREBASE_RETRY_ATTEMPTS) {
              this._log(`Retrying fetch for ${productId}, attempt ${attempt + 1}`);
              setTimeout(() => {
                this.fetchProductData(productId, attempt + 1)
                  .then(resolve)
                  .catch(reject);
              }, config.FIREBASE_RETRY_DELAY * attempt);
            } else {
              reject(error);
            }
          });
      });
      
      this.pendingRequests[productId] = request;
      return request;
    },

    // Batch fetch multiple products
    async fetchMultipleProducts(productIds) {
      const promises = productIds.map(id => 
        this.fetchProductData(id).catch(err => {
          console.warn(`Failed to fetch product ${id}:`, err);
          return null;
        })
      );
      
      return Promise.allSettled(promises);
    },

    // Get product images array
    getProductImages(productData) {
      if (!productData) return [];
      
      const images = [];
      const imageKeys = ['img_main', 'img01', 'img02', 'img03', 'img04', 'img05'];
      
      imageKeys.forEach(key => {
        const imgUrl = productData[key];
        if (imgUrl && typeof imgUrl === 'string' && imgUrl.includes('http')) {
          images.push({
            src: imgUrl,
            thumb: this.generateOptimizedThumb(imgUrl)
          });
        }
      });
      
      // Remove duplicates
      const uniqueImages = images.filter((img, index, arr) => 
        arr.findIndex(item => item.src === img.src) === index
      );
      
      return uniqueImages;
    },

    // Get prioritized images (img_main first)
    getPrioritizedImages(productData) {
      if (!productData) return [];
      
      const images = [];
      
      // Priority 1: img_main
      const imgMainUrl = productData['img_main'];
      if (imgMainUrl && typeof imgMainUrl === 'string' && imgMainUrl.includes('http')) {
        images.push({
          src: imgMainUrl,
          thumb: this.generateOptimizedThumb(imgMainUrl)
        });
      }
      
      // Priority 2: img01-05 (excluding duplicates)
      const imageKeys = ['img01', 'img02', 'img03', 'img04', 'img05'];
      imageKeys.forEach(key => {
        const imgUrl = productData[key];
        if (imgUrl && typeof imgUrl === 'string' && imgUrl.includes('http')) {
          // Avoid duplicate if same as img_main
          if (imgUrl !== imgMainUrl) {
            images.push({
              src: imgUrl,
              thumb: this.generateOptimizedThumb(imgUrl)
            });
          }
        }
      });
      
      return images;
    },

    // Generate optimized thumbnail
    generateOptimizedThumb(imgUrl) {
      if (window.DorikConfig && window.DorikConfig.Utils) {
        return window.DorikConfig.Utils.generateOptimizedThumb(imgUrl);
      }
      return imgUrl;
    },

    // Preload product data for containers in viewport
    async preloadContainerData(containerIds) {
      if (!Array.isArray(containerIds)) return;
      
      const config = window.DorikConfig ? window.DorikConfig.get('PERFORMANCE') : { BATCH_SIZE: 30 };
      const batches = [];
      
      // Split into batches
      for (let i = 0; i < containerIds.length; i += config.BATCH_SIZE) {
        batches.push(containerIds.slice(i, i + config.BATCH_SIZE));
      }
      
      // Process batches sequentially
      for (const batch of batches) {
        await this.fetchMultipleProducts(batch);
        // Small delay between batches to prevent overwhelming
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    },

    // Health check
    async healthCheck() {
      try {
        await this.init();
        
        // Try to read from a known path
        const testRef = firebase.database().ref('.info/connected');
        return new Promise((resolve) => {
          testRef.once('value', (snapshot) => {
            resolve(snapshot.val() === true);
          });
        });
      } catch (error) {
        return false;
      }
    },

    // Clear pending requests
    clearPendingRequests() {
      this.pendingRequests = {};
    },

    _log(message, data = null) {
      if (window.DorikConfig && window.DorikConfig.Utils) {
        window.DorikConfig.Utils.log(message, data);
      }
    }
  };

  // === PUBLIC API ===
  return {
    // Initialize Firebase
    init: () => FirebaseManager.init(),
    
    // Data fetching
    fetchProduct: (productId) => FirebaseManager.fetchProductData(productId),
    fetchMultiple: (productIds) => FirebaseManager.fetchMultipleProducts(productIds),
    preloadContainers: (containerIds) => FirebaseManager.preloadContainerData(containerIds),
    
    // Image utilities
    getImages: (productData) => FirebaseManager.getProductImages(productData),
    getPrioritizedImages: (productData) => FirebaseManager.getPrioritizedImages(productData),
    
    // System utilities
    healthCheck: () => FirebaseManager.healthCheck(),
    clearPending: () => FirebaseManager.clearPendingRequests(),
    
    // Status
    get isInitialized() { return FirebaseManager.initialized; },
    get pendingRequests() { return Object.keys(FirebaseManager.pendingRequests); }
  };

})();
