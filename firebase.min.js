/**
 * FIREBASE.MIN.JS - Firebase Operations
 * Data fetching với retry logic và caching
 */

(function() {
  'use strict';

  // === FIREBASE MANAGER ===
  window.DorikFirebase = {
    
    db: null,
    initialized: false,

    // Initialize Firebase
    async init() {
      try {
        // Load Firebase if not already loaded
        await this.loadFirebaseLibraries();
        
        // Initialize Firebase app if not already done
        if (!window.firebase?.apps?.length) {
          const config = window.firebaseConfig;
          if (!config) {
            throw new Error('Firebase config not found in window.firebaseConfig');
          }
          window.firebase.initializeApp(config);
        }
        
        // Get database reference
        this.db = window.firebase.database();
        this.initialized = true;
        
        window.DorikUtils?.log('✅ Firebase initialized');
        return true;
        
      } catch (error) {
        window.DorikUtils?.error('Firebase initialization failed:', error);
        return false;
      }
    },

    // Load Firebase libraries dynamically
    async loadFirebaseLibraries() {
      const config = window.DorikConfig;
      if (!config) {
        throw new Error('DorikConfig not found');
      }

      // Check if Firebase is already loaded
      if (window.firebase) {
        return;
      }

      try {
        // Load Firebase App
        await window.DorikUtils.loadJS(config.FIREBASE_APP, 'firebase-app');
        
        // Load Firebase Database
        await window.DorikUtils.loadJS(config.FIREBASE_DB, 'firebase-database');
        
        // Wait a bit for libraries to be ready
        await new Promise(resolve => setTimeout(resolve, 100));
        
        window.DorikUtils?.log('✅ Firebase libraries loaded');
        
      } catch (error) {
        throw new Error('Failed to load Firebase libraries: ' + error.message);
      }
    },

    // Fetch product data with retry logic
    async fetchProductData(containerId) {
      if (!this.initialized) {
        const initResult = await this.init();
        if (!initResult) {
          throw new Error('Firebase not initialized');
        }
      }

      // Check cache first
      const cachedData = window.DorikCache?.getProduct(containerId);
      if (cachedData) {
        window.DorikUtils?.log(`Cache hit for ${containerId}`);
        return cachedData;
      }

      const config = window.DorikConfig;
      const maxRetries = config.FIREBASE_RETRY_ATTEMPTS;
      const baseDelay = config.FIREBASE_RETRY_DELAY;
      
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          window.DorikUtils?.log(`Fetching ${containerId} (attempt ${attempt}/${maxRetries})`);
          
          const data = await this.fetchWithTimeout(containerId, config.FIREBASE_TIMEOUT);
          
          if (data) {
            // Cache the result
            window.DorikCache?.setProduct(containerId, data);
            window.DorikUtils?.log(`✅ Fetched and cached ${containerId}`);
            return data;
          } else {
            throw new Error('No data received');
          }
          
        } catch (error) {
          window.DorikUtils?.error(`Attempt ${attempt} failed for ${containerId}:`, error);
          
          if (attempt === maxRetries) {
            throw error;
          }
          
          // Exponential backoff delay
          const delay = baseDelay * Math.pow(2, attempt - 1);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    },

    // Fetch with timeout
    fetchWithTimeout(containerId, timeout) {
      return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          reject(new Error(`Timeout after ${timeout}ms`));
        }, timeout);

        this.db.ref(`products/${containerId}`).once('value')
          .then(snapshot => {
            clearTimeout(timeoutId);
            const data = snapshot.val();
            resolve(data);
          })
          .catch(error => {
            clearTimeout(timeoutId);
            reject(error);
          });
      });
    },

    // Batch fetch multiple products
    async fetchBatchProducts(containerIds) {
      const results = {};
      const fetchPromises = [];
      
      for (const containerId of containerIds) {
        // Skip if already cached
        if (window.DorikCache?.hasProduct(containerId)) {
          results[containerId] = window.DorikCache.getProduct(containerId);
          continue;
        }
        
        // Add to fetch queue
        fetchPromises.push(
          this.fetchProductData(containerId)
            .then(data => {
              results[containerId] = data;
            })
            .catch(error => {
              window.DorikUtils?.error(`Failed to fetch ${containerId}:`, error);
              results[containerId] = null;
            })
        );
      }
      
      // Wait for all fetches to complete
      if (fetchPromises.length > 0) {
        await Promise.all(fetchPromises);
      }
      
      return results;
    },

    // Preload product data in background
    async preloadProducts(containerIds, priority = 'low') {
      if (!Array.isArray(containerIds) || containerIds.length === 0) {
        return;
      }

      const uncachedIds = containerIds.filter(id => 
        !window.DorikCache?.hasProduct(id)
      );

      if (uncachedIds.length === 0) {
        return;
      }

      window.DorikUtils?.log(`Preloading ${uncachedIds.length} products (${priority} priority)`);

      // Process in smaller batches for better performance
      const deviceInfo = window.DorikState?.deviceInfo;
      const batchSize = deviceInfo?.isHighPerf ? 8 : 
                      deviceInfo?.isMobile ? 3 : 5;

      for (let i = 0; i < uncachedIds.length; i += batchSize) {
        const batch = uncachedIds.slice(i, i + batchSize);
        
        try {
          await this.fetchBatchProducts(batch);
          
          // Add delay between batches on slow connections
          if (deviceInfo?.isSlowConnection && i + batchSize < uncachedIds.length) {
            await new Promise(resolve => setTimeout(resolve, 500));
          }
          
        } catch (error) {
          window.DorikUtils?.error('Batch preload error:', error);
        }
      }
    },

    // Get product images for gallery
    getProductImages(productData) {
      if (!productData) return [];
      
      const images = [];
      
      // Add main image first
      if (productData.img_main) {
        images.push({
          src: productData.img_main,
          thumb: productData.img_main,
          title: productData.name || '',
          type: 'main'
        });
      }
      
      // Add additional images
      for
