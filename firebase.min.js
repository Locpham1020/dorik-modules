/**
 * FIREBASE.MIN.JS - Firebase Operations Module
 * Data fetching v·ªõi retry logic, caching v√† fallbacks
 */

(function() {
  'use strict';

  // === FIREBASE MANAGER ===
  window.DorikFirebase = {
    
    db: null,
    initialized: false,
    initPromise: null,

    // Initialize Firebase
    async init() {
      // Prevent multiple initializations
      if (this.initPromise) {
        return this.initPromise;
      }

      this.initPromise = this._performInit();
      return this.initPromise;
    },

    async _performInit() {
      try {
        window.DorikUtils?.log('üîÑ Initializing Firebase...');
        
        // Check if Firebase libraries are available
        if (!window.firebase) {
          // Try to load Firebase libraries
          await this.loadFirebaseLibraries();
        }
        
        // Check Firebase config
        if (!window.firebaseConfig) {
          throw new Error('Firebase config not found in window.firebaseConfig');
        }
        
        // Initialize Firebase app if not already done
        if (!window.firebase.apps || window.firebase.apps.length === 0) {
          window.firebase.initializeApp(window.firebaseConfig);
          window.DorikUtils?.log('‚úÖ Firebase app initialized');
        } else {
          window.DorikUtils?.log('‚úÖ Firebase app already initialized');
        }
        
        // Get database reference
        this.db = window.firebase.database();
        this.initialized = true;
        
        // Update global state
        if (window.DorikState) {
          window.DorikState.flags.firebaseReady = true;
        }
        
        // Test connection
        const connected = await this.testConnection();
        window.DorikUtils?.log('üåê Firebase connection:', connected ? 'Connected' : 'Disconnected');
        
        window.DorikUtils?.log('‚úÖ Firebase module ready');
        return true;
        
      } catch (error) {
        window.DorikUtils?.error('‚ùå Firebase initialization failed:', error);
        this.initialized = false;
        return false;
      }
    },

    // Load Firebase libraries dynamically
    async loadFirebaseLibraries() {
      if (window.firebase) {
        return;
      }

      try {
        window.DorikUtils?.log('üì¶ Loading Firebase libraries...');
        
        // Load Firebase App
        await window.DorikUtils.loadJS(
          'https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js', 
          'firebase-app'
        );
        
        // Load Firebase Database
        await window.DorikUtils.loadJS(
          'https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js', 
          'firebase-database'
        );
        
        // Wait for libraries to be ready
        await window.DorikUtils.waitFor(() => window.firebase, 3000);
        
        window.DorikUtils?.log('‚úÖ Firebase libraries loaded');
        
      } catch (error) {
        throw new Error('Failed to load Firebase libraries: ' + error.message);
      }
    },

    // Test Firebase connection
    async testConnection() {
      if (!this.db) {
        return false;
      }

      try {
        const connectedRef = this.db.ref('.info/connected');
        const snapshot = await connectedRef.once('value');
        return snapshot.val();
      } catch (error) {
        window.DorikUtils?.error('Connection test failed:', error);
        return false;
      }
    },

    // Fetch product data with comprehensive retry logic
    async fetchProductData(containerId) {
      if (!containerId) {
        throw new Error('Container ID is required');
      }

      // Check cache first
      const cachedData = window.DorikCache?.getProduct(containerId);
      if (cachedData) {
        window.DorikUtils?.log(`üì¶ Cache hit for ${containerId}`);
        return cachedData;
      }

      // Ensure Firebase is initialized
      if (!this.initialized) {
        const initResult = await this.init();
        if (!initResult) {
          throw new Error('Firebase not available');
        }
      }

      const config = window.DorikConfig;
      const maxRetries = config.FIREBASE_RETRY_ATTEMPTS || 3;
      const baseDelay = config.FIREBASE_RETRY_DELAY || 1000;
      
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          window.DorikUtils?.log(`üîÑ Fetching ${containerId} (attempt ${attempt}/${maxRetries})`);
          
          const data = await this.fetchWithTimeout(containerId, config.FIREBASE_TIMEOUT || 5000);
          
          if (data) {
            // Cache the result
            window.DorikCache?.setProduct(containerId, data);
            window.DorikUtils?.log(`‚úÖ Fetched and cached ${containerId}`);
            return data;
          } else {
            throw new Error('No data received');
          }
          
        } catch (error) {
          window.DorikUtils?.error(`‚ùå Attempt ${attempt} failed for ${containerId}:`, error.message);
          
          if (attempt === maxRetries) {
            // Final attempt failed, return mock data
            return this.createMockData(containerId);
          }
          
          // Exponential backoff delay
          const delay = baseDelay * Math.pow(2, attempt - 1);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    },

    // Fetch with timeout
    fetchWithTimeout(containerId, timeout) {
      return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          reject(new Error(`Timeout after ${timeout}ms`));
        }, timeout);

        this.db.ref(`products/${containerId}`).once('value')
          .then(snapshot => {
            clearTimeout(timeoutId);
            const data = snapshot.val();
            resolve(data);
          })
          .catch(error => {
            clearTimeout(timeoutId);
            reject(error);
          });
      });
    },

    // Create mock data fallback
    createMockData(containerId) {
      window.DorikUtils?.log(`üé≠ Creating mock data for ${containerId}`);
      
      const mockData = {
        name: `Product ${containerId}`,
        price: '999,000 VND',
        description: `Mock description for ${containerId}`,
        img_main: 'https://via.placeholder.com/800x800/4f46e5/ffffff?text=Main+Image',
        img01: 'https://via.placeholder.com/800x800/059669/ffffff?text=Image+1',
        img02: 'https://via.placeholder.com/800x800/dc2626/ffffff?text=Image+2',
        img03: 'https://via.placeholder.com/800x800/ea580c/ffffff?text=Image+3',
        img04: 'https://via.placeholder.com/800x800/7c3aed/ffffff?text=Image+4',
        img05: 'https://via.placeholder.com/800x800/059669/ffffff?text=Image+5',
        category: 'mock',
        availability: 'in_stock',
        mock: true
      };
      
      // Cache mock data
      window.DorikCache?.setProduct(containerId, mockData);
      
      return mockData;
    },

    // Batch fetch multiple products
    async fetchBatchProducts(containerIds) {
      if (!Array.isArray(containerIds) || containerIds.length === 0) {
        return {};
      }

      const results = {};
      const fetchPromises = [];
      
      window.DorikUtils?.log(`üîÑ Batch fetching ${containerIds.length} products`);
      
      for (const containerId of containerIds) {
        // Skip if already cached
        if (window.DorikCache?.hasProduct(containerId)) {
          results[containerId] = window.DorikCache.getProduct(containerId);
          continue;
        }
        
        // Add to fetch queue with individual error handling
        fetchPromises.push(
          this.fetchProductData(containerId)
            .then(data => {
              results[containerId] = data;
              return { containerId, success: true, data };
            })
            .catch(error => {
              window.DorikUtils?.error(`‚ùå Batch fetch failed for ${containerId}:`, error.message);
              const mockData = this.createMockData(containerId);
              results[containerId] = mockData;
              return { containerId, success: false, data: mockData, error: error.message };
            })
        );
      }
      
      // Wait for all fetches to complete
      if (fetchPromises.length > 0) {
        const fetchResults = await Promise.all(fetchPromises);
        const successCount = fetchResults.filter(r => r.success).length;
        const failCount = fetchResults.filter(r => !r.success).length;
        
        window.DorikUtils?.log(`‚úÖ Batch complete: ${successCount} success, ${failCount} fallback`);
      }
      
      return results;
    },

    // Preload products in background
    async preloadProducts(containerIds, priority = 'low') {
      if (!Array.isArray(containerIds) || containerIds.length === 0) {
        return;
      }

      const uncachedIds = containerIds.filter(id => 
        !window.DorikCache?.hasProduct(id)
      );

      if (uncachedIds.length === 0) {
        window.DorikUtils?.log('üì¶ All products already cached');
        return;
      }

      window.DorikUtils?.log(`üîÑ Preloading ${uncachedIds.length} products (${priority} priority)`);

      // Process in smaller batches for better performance
      const deviceInfo = window.DorikState?.deviceInfo;
      const batchSize = deviceInfo?.isHighPerf ? 8 : 
                      deviceInfo?.isMobile ? 3 : 5;

      for (let i = 0; i < uncachedIds.length; i += batchSize) {
        const batch = uncachedIds.slice(i, i + batchSize);
        
        try {
          await this.fetchBatchProducts(batch);
          
          // Add delay between batches on slow connections
          if (deviceInfo?.isSlowConnection && i + batchSize < uncachedIds.length) {
            await new Promise(resolve => setTimeout(resolve, 500));
          }
          
        } catch (error) {
          window.DorikUtils?.error('‚ùå Batch preload error:', error);
        }
      }
    },

    // Get product images for gallery
    getProductImages(productData) {
      if (!productData) {
        return [];
      }
      
      const images = [];
      
      // Add main image first
      if (productData.img_main) {
        images.push({
          src: productData.img_main,
          thumb: productData.img_main,
          title: productData.name || 'Main Image',
          type: 'main'
        });
      }
      
      // Add additional images (img01-img05)
      for (let i = 1; i <= 5; i++) {
        const imgKey = `img${i.toString().padStart(2, '0')}`;
        if (productData[imgKey]) {
          images.push({
            src: productData[imgKey],
            thumb: productData[imgKey],
            title: productData.name || `Image ${i}`,
            type: 'additional',
            index: i
          });
        }
      }
      
      return images;
    },

    // Preload product images
    async preloadProductImages(productData, priority = 'low') {
      const images = this.getProductImages(productData);
      const urls = images.map(img => img.src);
      
      if (urls.length > 0 && window.DorikCache?.preloadImages) {
        try {
          await window.DorikCache.preloadImages(urls, priority);
          window.DorikUtils?.log(`‚úÖ Preloaded ${urls.length} images`);
        } catch (error) {
          window.DorikUtils?.error('‚ùå Image preload error:', error);
        }
      }
    },

    // Search products
    async searchProducts(query, limit = 10) {
      if (!this.initialized) {
        await this.init();
      }

      try {
        window.DorikUtils?.log(`üîç Searching products: "${query}"`);
        
        const snapshot = await this.db.ref('products')
          .orderByChild('name')
          .startAt(query)
          .endAt(query + '\uf8ff')
          .limitToFirst(limit)
          .once('value');
          
        const results = snapshot.val() || {};
        const searchResults = Object.entries(results).map(([id, data]) => ({
          id,
          ...data
        }));
        
        window.DorikUtils?.log(`üîç Found ${searchResults.length} products`);
        return searchResults;
        
      } catch (error) {
        window.DorikUtils?.error('‚ùå Search failed:', error);
        return [];
      }
    },

    // Get product categories
    async getCategories() {
      if (!this.initialized) {
        await this.init();
      }

      try {
        const snapshot = await this.db.ref('categories').once('value');
        const categories = snapshot.val() || {};
        return Object.entries(categories).map(([id, data]) => ({
          id,
          ...data
        }));
      } catch (error) {
        window.DorikUtils?.error('‚ùå Categories fetch failed:', error);
        return [];
      }
    },

    // Health check
    async healthCheck() {
      const health = {
        initialized: this.initialized,
        timestamp: new Date().toISOString()
      };

      if (!this.initialized) {
        health.status = 'not_initialized';
        return health;
      }

      try {
        const startTime = Date.now();
        const connected = await this.testConnection();
        const responseTime = Date.now() - startTime;
        
        health.status = connected ? 'connected' : 'disconnected';
        health.responseTime = responseTime;
        
        return health;
        
      } catch (error) {
        health.status = 'error';
        health.error = error.message;
        return health;
      }
    },

    // Get Firebase stats
    getStats() {
      return {
        initialized: this.initialized,
        hasDatabase: !!this.db,
        firebaseApps: window.firebase?.apps?.length || 0,
        timestamp: new Date().toISOString()
      };
    },

    // Cleanup
    cleanup() {
      this.db = null;
      this.initialized = false;
      this.initPromise = null;
      
      if (window.DorikState) {
        window.DorikState.flags.firebaseReady = false;
      }
      
      window.DorikUtils?.log('üßπ Firebase module cleaned up');
    }
  };

  window.DorikUtils?.log('‚úÖ Firebase module loaded');

})();
