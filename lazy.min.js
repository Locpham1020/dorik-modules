/**
 * LAZY.MIN.JS - Lazy Loading System Module
 * IntersectionObserver, batch processing, smart preloading
 */

(function() {
  'use strict';

  // === LAZY LOADING SYSTEM ===
  window.DorikLazy = {
    
    observer: null,
    containersToLoad: [],
    isProcessing: false,
    initialized: false,

    // Initialize lazy loading system
    init() {
      window.DorikUtils?.log('üëÅÔ∏è Initializing lazy loading system...');
      
      // Create intersection observer
      this.createObserver();
      
      // Find and observe containers
      this.observeContainers();
      
      // Setup performance monitoring
      this.setupPerformanceMonitoring();
      
      this.initialized = true;
      window.DorikUtils?.log('‚úÖ Lazy loading system ready');
    },

    // Create intersection observer
    createObserver() {
      const config = window.DorikConfig;
      if (!config) {
        window.DorikUtils?.error('DorikConfig not found');
        return;
      }

      const observerOptions = {
        rootMargin: config.VIEWPORT_MARGIN || '100px',
        threshold: [0, 0.1, 0.25, 0.5, 0.75, 1.0]
      };

      this.observer = new IntersectionObserver(
        this.handleIntersection.bind(this),
        observerOptions
      );

      // Store observer reference in global state
      if (window.DorikState) {
        window.DorikState.observers.intersection = this.observer;
      }

      window.DorikUtils?.log('üëÅÔ∏è Intersection observer created');
    },

    // Find and observe all containers
    observeContainers() {
      // Find all potential product containers
      const containerSelectors = [
        '[id^="container-"]',
        '[id*="Nuochoa"]',
        '[id*="nuochoa"]',
        '[class*="product"]',
        '[data-product]',
        '[data-container]'
      ];

      const containers = new Set();
      
      containerSelectors.forEach(selector => {
        try {
          const elements = document.querySelectorAll(selector);
          elements.forEach(el => {
            if (el.id) { // Only containers with IDs
              containers.add(el);
            }
          });
        } catch (error) {
          window.DorikUtils?.error('Invalid selector:', selector);
        }
      });

      // Observe all found containers
      containers.forEach(container => {
        this.observer.observe(container);
      });

      window.DorikUtils?.log(`üëÅÔ∏è Observing ${containers.size} containers`);
      return containers.size;
    },

    // Handle intersection events
    async handleIntersection(entries) {
      const containersToLoad = [];

      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const containerId = entry.target.id;
          
          // Skip if already processed
          if (window.DorikState?.processedContainers.has(containerId)) {
            return;
          }

          // Calculate priority based on intersection ratio and distance
          const priority = this.calculatePriority(entry);
          
          containersToLoad.push({
            id: containerId,
            element: entry.target,
            intersectionRatio: entry.intersectionRatio,
            distance: window.DorikUtils?.getDistanceFromViewport(entry.target) || 0,
            priority: priority
          });
        }
      });

      if (containersToLoad.length === 0) {
        return;
      }

      // Sort by priority (higher priority first)
      containersToLoad.sort((a, b) => b.priority - a.priority);

      // Add to processing queue
      this.containersToLoad.push(...containersToLoad);

      // Process queue if not already processing
      if (!this.isProcessing) {
        await this.processPendingContainers();
      }
    },

    // Calculate container loading priority
    calculatePriority(entry) {
      let priority = 0;
      
      // Higher intersection ratio = higher priority
      priority += entry.intersectionRatio * 100;
      
      // Elements in center of viewport get higher priority
      const rect = entry.boundingClientRect;
      const viewportCenter = window.innerHeight / 2;
      const elementCenter = rect.top + rect.height / 2;
      const distanceFromCenter = Math.abs(viewportCenter - elementCenter);
      const centerBonus = Math.max(0, 50 - (distanceFromCenter / 10));
      priority += centerBonus;
      
      // Elements that are fully visible get bonus
      if (entry.intersectionRatio >= 0.9) {
        priority += 25;
      }
      
      return Math.round(priority);
    },

    // Process pending containers
    async processPendingContainers() {
      if (this.isProcessing || this.containersToLoad.length === 0) {
        return;
      }

      this.isProcessing = true;
      
      try {
        const config = window.DorikConfig;
        const batchSize = config?.BATCH_SIZE || 30;
        
        window.DorikUtils?.log(`üì¶ Processing ${this.containersToLoad.length} pending containers`);

        // Process in batches
        while (this.containersToLoad.length > 0) {
          const batch = this.containersToLoad.splice(0, batchSize);
          await this.processBatch(batch);
          
          // Add delay between batches on slow connections
          const deviceInfo = window.DorikState?.deviceInfo;
          if (deviceInfo?.isSlowConnection && this.containersToLoad.length > 0) {
            await new Promise(resolve => setTimeout(resolve, 200));
          }
        }

      } catch (error) {
        window.DorikUtils?.error('‚ùå Container processing error:', error);
      } finally {
        this.isProcessing = false;
      }
    },

    // Process batch of containers
    async processBatch(containers) {
      const containerIds = containers.map(c => c.id);
      
      try {
        window.DorikUtils?.log(`üì¶ Processing batch: ${containerIds.length} containers`);
        
        // Preload product data using Firebase module
        if (window.DorikFirebase?.preloadProducts) {
          await window.DorikFirebase.preloadProducts(containerIds, 'high');
        } else {
          // Fallback: individual loading
          for (const container of containers) {
            try {
              if (window.DorikFirebase?.fetchProductData) {
                await window.DorikFirebase.fetchProductData(container.id);
              }
            } catch (error) {
              window.DorikUtils?.error(`Failed to load ${container.id}:`, error);
            }
          }
        }

        // Mark containers as processed
        if (window.DorikState) {
          containerIds.forEach(id => {
            window.DorikState.processedContainers.add(id);
            window.DorikState.counters.lazyLoaded++;
          });
        }

        window.DorikUtils?.log(`‚úÖ Batch completed: ${containerIds.length} containers processed`);

      } catch (error) {
        window.DorikUtils?.error('‚ùå Batch processing failed:', error);
      }
    },

    // Setup performance monitoring
    setupPerformanceMonitoring() {
      // Monitor scroll performance
      let lastScrollTime = 0;
      let scrollVelocity = 0;
      
      const scrollHandler = window.DorikUtils?.throttle(() => {
        const currentTime = Date.now();
        const deltaTime = currentTime - lastScrollTime;
        
        if (deltaTime > 0) {
          scrollVelocity = Math.abs(window.scrollY - (this.lastScrollY || 0)) / deltaTime;
          this.lastScrollY = window.scrollY;
        }
        
        lastScrollTime = currentTime;
        
        // Adjust processing based on scroll speed
        this.adjustProcessingSpeed(scrollVelocity);
        
      }, 100);
      
      window.addEventListener('scroll', scrollHandler, { passive: true });
      
      // Monitor memory usage
      this.setupMemoryMonitoring();
    },

    // Adjust processing speed based on scroll velocity
    adjustProcessingSpeed(velocity) {
      // If user is scrolling fast, reduce processing to maintain smooth scrolling
      if (velocity > 2) { // Fast scrolling
        this.processingDelay = 500;
      } else if (velocity > 1) { // Medium scrolling
        this.processingDelay = 200;
      } else { // Slow or no scrolling
        this.processingDelay = 50;
      }
    },

    // Setup memory monitoring
    setupMemoryMonitoring() {
      setInterval(() => {
        const memoryInfo = window.DorikUtils?.getMemoryInfo();
        if (memoryInfo && memoryInfo.used_mb > 100) { // If using more than 100MB
          window.DorikUtils?.log(`‚ö†Ô∏è High memory usage: ${memoryInfo.used_mb}MB`);
          
          // Reduce batch size for memory-constrained environments
          if (window.DorikConfig) {
            window.DorikConfig.BATCH_SIZE = Math.max(5, Math.floor(window.DorikConfig.BATCH_SIZE * 0.8));
          }
        }
      }, 30000); // Check every 30 seconds
    },

    // Manually trigger container loading
    async loadContainer(containerId) {
      if (!containerId) {
        window.DorikUtils?.error('Container ID required');
        return false;
      }

      // Skip if already processed
      if (window.DorikState?.processedContainers.has(containerId)) {
        window.DorikUtils?.log(`üì¶ Container ${containerId} already processed`);
        return true;
      }

      try {
        window.DorikUtils?.log(`üîÑ Manually loading container: ${containerId}`);
        
        // Load product data
        if (window.DorikFirebase?.fetchProductData) {
          await window.DorikFirebase.fetchProductData(containerId);
        }

        // Mark as processed
        if (window.DorikState) {
          window.DorikState.processedContainers.add(containerId);
          window.DorikState.counters.lazyLoaded++;
        }

        window.DorikUtils?.log(`‚úÖ Container ${containerId} loaded manually`);
        return true;

      } catch (error) {
        window.DorikUtils?.error(`‚ùå Manual loading failed for ${containerId}:`, error);
        return false;
      }
    },

    // Load containers in viewport immediately
    async loadVisibleContainers() {
      const visibleContainers = [];
      
      // Find all observed containers that are currently visible
      const containers = document.querySelectorAll('[id^="container-"], [id*="Nuochoa"], [id*="nuochoa"]');
      
      containers.forEach(container => {
        if (window.DorikUtils?.isInViewport(container, 50)) {
          visibleContainers.push({
            id: container.id,
            element: container,
            priority: 100 // High priority for visible items
          });
        }
      });

      if (visibleContainers.length > 0) {
        window.DorikUtils?.log(`üéØ Loading ${visibleContainers.length} visible containers`);
        await this.processBatch(visibleContainers);
      }
    },

    // Preload containers near viewport
    async preloadNearbyContainers(distance = 300) {
      const nearbyContainers = [];
      
      const containers = document.querySelectorAll('[id^="container-"], [id*="Nuochoa"], [id*="nuochoa"]');
      
      containers.forEach(container => {
        const distanceFromViewport = window.DorikUtils?.getDistanceFromViewport(container) || 0;
        
        if (distanceFromViewport > 0 && distanceFromViewport <= distance) {
          // Skip if already processed
          if (!window.DorikState?.processedContainers.has(container.id)) {
            nearbyContainers.push({
              id: container.id,
              element: container,
              distance: distanceFromViewport,
              priority: Math.max(1, 50 - distanceFromViewport / 10)
            });
          }
        }
      });

      if (nearbyContainers.length > 0) {
        // Sort by distance (closest first)
        nearbyContainers.sort((a, b) => a.distance - b.distance);
        
        window.DorikUtils?.log(`üîÆ Preloading ${nearbyContainers.length} nearby containers`);
        await this.processBatch(nearbyContainers);
      }
    },

    // Get lazy loading stats
    getStats() {
      const observedElements = this.observer ? 
        document.querySelectorAll('[id^="container-"], [id*="Nuochoa"], [id*="nuochoa"]').length : 0;
      
      return {
        initialized: this.initialized,
        observedElements: observedElements,
        processedContainers: window.DorikState?.processedContainers.size || 0,
        pendingContainers: this.containersToLoad.length,
        isProcessing: this.isProcessing,
        totalLazyLoaded: window.DorikState?.counters.lazyLoaded || 0
      };
    },

    // Refresh observer (useful after DOM changes)
    refresh() {
      if (!this.observer) {
        window.DorikUtils?.error('Observer not initialized');
        return;
      }

      // Disconnect and reconnect observer
      this.observer.disconnect();
      
      // Re-observe containers
      const observedCount = this.observeContainers();
      
      window.DorikUtils?.log(`üîÑ Lazy loading refreshed: ${observedCount} containers`);
    },

    // Pause lazy loading
    pause() {
      if (this.observer) {
        this.observer.disconnect();
        window.DorikUtils?.log('‚è∏Ô∏è Lazy loading paused');
      }
    },

    // Resume lazy loading
    resume() {
      if (this.observer) {
        this.observeContainers();
        window.DorikUtils?.log('‚ñ∂Ô∏è Lazy loading resumed');
      }
    },

    // Cleanup
    cleanup() {
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      }

      this.containersToLoad = [];
      this.isProcessing = false;
      this.initialized = false;

      // Clear global state references
      if (window.DorikState?.observers) {
        window.DorikState.observers.intersection = null;
      }

      window.DorikUtils?.log('üßπ Lazy loading system cleaned up');
    }
  };

  window.DorikUtils?.log('‚úÖ Lazy loading module loaded');

})();
