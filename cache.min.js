/**
 * CACHE MODULE - Smart Cache Management
 * URL: https://yourname.github.io/dorik-modules/cache.min.js
 */

window.DorikCache = (function() {
  'use strict';

  // === SMART CACHE CLASS ===
  class SmartCache {
    constructor(maxSize, maxMemoryMB) {
      this.cache = new Map();
      this.accessTimes = new Map();
      this.memorySizes = new Map();
      this.maxSize = maxSize;
      this.maxMemoryBytes = maxMemoryMB * 1024 * 1024;
      this.currentMemoryUsage = 0;
    }

    set(key, value, estimatedSizeKB = 10) {
      const sizeBytes = estimatedSizeKB * 1024;
      
      if (this.cache.has(key)) {
        this.currentMemoryUsage -= this.memorySizes.get(key) || 0;
      }
      
      if (this.currentMemoryUsage + sizeBytes > this.maxMemoryBytes) {
        this._evictMemory(sizeBytes);
      }
      
      if (this.cache.size >= this.maxSize) {
        this._evictLRU();
      }
      
      this.cache.set(key, value);
      this.accessTimes.set(key, Date.now());
      this.memorySizes.set(key, sizeBytes);
      this.currentMemoryUsage += sizeBytes;
      
      this._log(`Cache SET: ${key}, Memory: ${(this.currentMemoryUsage / 1024 / 1024).toFixed(1)}MB`);
    }

    get(key) {
      if (this.cache.has(key)) {
        this.accessTimes.set(key, Date.now());
        return this.cache.get(key);
      }
      return null;
    }

    has(key) {
      return this.cache.has(key);
    }

    delete(key) {
      this._remove(key);
    }

    _evictLRU() {
      let oldestKey = null;
      let oldestTime = Date.now();
      
      this.accessTimes.forEach((time, key) => {
        if (time < oldestTime) {
          oldestTime = time;
          oldestKey = key;
        }
      });
      
      if (oldestKey) {
        this._remove(oldestKey);
        this._log(`LRU Evicted: ${oldestKey}`);
      }
    }

    _evictMemory(neededBytes) {
      while (this.currentMemoryUsage + neededBytes > this.maxMemoryBytes && this.cache.size > 0) {
        this._evictLRU();
      }
    }

    _remove(key) {
      this.cache.delete(key);
      this.accessTimes.delete(key);
      const size = this.memorySizes.get(key) || 0;
      this.memorySizes.delete(key);
      this.currentMemoryUsage -= size;
    }

    clear() {
      this.cache.clear();
      this.accessTimes.clear();
      this.memorySizes.clear();
      this.currentMemoryUsage = 0;
    }

    getStats() {
      return {
        size: this.cache.size,
        memoryMB: (this.currentMemoryUsage / 1024 / 1024).toFixed(1),
        maxSize: this.maxSize,
        maxMemoryMB: (this.maxMemoryBytes / 1024 / 1024).toFixed(1)
      };
    }

    _log(message) {
      if (window.DorikConfig && window.DorikConfig.Utils) {
        window.DorikConfig.Utils.log(message);
      }
    }
  }

  // === CACHE MANAGER ===
  const CacheManager = {
    // Cache instances
    productCache: null,
    imageCache: null,
    
    // Initialization
    init(config = {}) {
      const cacheConfig = window.DorikConfig ? window.DorikConfig.get('CACHE') : {
        MAX_PRODUCT_CACHE: 100,
        MAX_IMAGE_CACHE: 200,
        MAX_MEMORY_MB: 50,
        CLEANUP_INTERVAL: 180000
      };
      
      this.productCache = new SmartCache(
        config.maxProductCache || cacheConfig.MAX_PRODUCT_CACHE, 
        (config.maxMemoryMB || cacheConfig.MAX_MEMORY_MB) * 0.7
      );
      
      this.imageCache = new SmartCache(
        config.maxImageCache || cacheConfig.MAX_IMAGE_CACHE,
        (config.maxMemoryMB || cacheConfig.MAX_MEMORY_MB) * 0.3
      );
      
      this.setupCleanup(config.cleanupInterval || cacheConfig.CLEANUP_INTERVAL);
      
      this._log('Cache Manager initialized');
      return this;
    },

    // Product Cache Methods
    setProduct(key, data) {
      if (!this.productCache) this.init();
      this.productCache.set(key, data, 15);
    },

    getProduct(key) {
      if (!this.productCache) this.init();
      return this.productCache.get(key);
    },

    hasProduct(key) {
      if (!this.productCache) this.init();
      return this.productCache.has(key);
    },

    // Image Cache Methods
    setImage(url, loaded = true) {
      if (!this.imageCache) this.init();
      this.imageCache.set(url, loaded, loaded ? 200 : 1);
    },

    getImage(url) {
      if (!this.imageCache) this.init();
      return this.imageCache.get(url);
    },

    hasImage(url) {
      if (!this.imageCache) this.init();
      return this.imageCache.has(url);
    },

    // Preload Images
    preloadImage(url) {
      if (!url || this.hasImage(url)) return Promise.resolve();
      
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          this.setImage(url, true);
          this._log(`Image preloaded: ${url}`);
          resolve(true);
        };
        img.onerror = () => {
          this.setImage(url, false);
          resolve(false);
        };
        img.src = url;
      });
    },

    // Smart Image Preloading
    smartPreloadImages(productData) {
      const deviceInfo = window.DorikConfig ? window.DorikConfig.Utils.getDeviceInfo() : { isSlowConnection: false };
      const config = window.DorikConfig ? window.DorikConfig.get('PERFORMANCE') : { PRELOAD_NEXT_ONLY: true };
      
      // Priority load img01 immediately
      const img01Url = productData['img01'];
      if (img01Url && typeof img01Url === 'string' && img01Url.includes('http')) {
        this.preloadImage(img01Url);
      }
      
      // Smart preloading based on device performance
      if (config.PRELOAD_NEXT_ONLY || deviceInfo.isSlowConnection) {
        const img02Url = productData['img02'];
        if (img02Url && typeof img02Url === 'string' && img02Url.includes('http')) {
          setTimeout(() => this.preloadImage(img02Url), 500);
        }
      } else {
        const imageKeys = ['img02', 'img03', 'img04', 'img05'];
        imageKeys.forEach((key, index) => {
          const imgUrl = productData[key];
          if (imgUrl && typeof imgUrl === 'string' && imgUrl.includes('http')) {
            setTimeout(() => this.preloadImage(imgUrl), (index + 1) * 400);
          }
        });
      }
    },

    // Cache Statistics
    getStats() {
      if (!this.productCache || !this.imageCache) return null;
      
      return {
        product: this.productCache.getStats(),
        image: this.imageCache.getStats(),
        total: {
          items: this.productCache.cache.size + this.imageCache.cache.size,
          memoryMB: (this.productCache.currentMemoryUsage + this.imageCache.currentMemoryUsage) / 1024 / 1024
        }
      };
    },

    // Setup automatic cleanup
    setupCleanup(interval) {
      setInterval(() => {
        this.cleanup();
      }, interval);
    },

    // Manual cleanup
    cleanup() {
      if (!this.productCache || !this.imageCache) return;
      
      const beforeStats = this.getStats();
      
      // Check memory usage
      if (performance.memory) {
        const memoryUsage = performance.memory.usedJSHeapSize / 1024 / 1024;
        
        if (memoryUsage > 100) {
          this._log(`High memory usage detected: ${memoryUsage.toFixed(1)}MB - Aggressive cleanup`);
          
          // Aggressive cleanup
          while (this.productCache.cache.size > this.productCache.maxSize * 0.5) {
            this.productCache._evictLRU();
          }
          while (this.imageCache.cache.size > this.imageCache.maxSize * 0.5) {
            this.imageCache._evictLRU();
          }
        }
      }
      
      const afterStats = this.getStats();
      this._log('Cache cleanup completed:', { before: beforeStats, after: afterStats });
    },

    // Clear all caches
    clear() {
      if (this.productCache) this.productCache.clear();
      if (this.imageCache) this.imageCache.clear();
      this._log('All caches cleared');
    },

    _log(message, data = null) {
      if (window.DorikConfig && window.DorikConfig.Utils) {
        window.DorikConfig.Utils.log(message, data);
      }
    }
  };

  // === PUBLIC API ===
  return {
    // Initialize cache manager
    init: (config) => CacheManager.init(config),
    
    // Product cache methods
    setProduct: (key, data) => CacheManager.setProduct(key, data),
    getProduct: (key) => CacheManager.getProduct(key),
    hasProduct: (key) => CacheManager.hasProduct(key),
    
    // Image cache methods
    setImage: (url, loaded) => CacheManager.setImage(url, loaded),
    getImage: (url) => CacheManager.getImage(url),
    hasImage: (url) => CacheManager.hasImage(url),
    preloadImage: (url) => CacheManager.preloadImage(url),
    smartPreloadImages: (data) => CacheManager.smartPreloadImages(data),
    
    // Cache management
    getStats: () => CacheManager.getStats(),
    cleanup: () => CacheManager.cleanup(),
    clear: () => CacheManager.clear(),
    
    // Direct access to cache instances (for advanced usage)
    get productCache() { return CacheManager.productCache; },
    get imageCache() { return CacheManager.imageCache; }
  };

})();
