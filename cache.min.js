/**
 * CACHE.MIN.JS - Smart Cache System Module
 * LRU cache v·ªõi memory management cho products & images
 */

(function() {
  'use strict';

  // === SMART CACHE CLASS ===
  class SmartCache {
    constructor(maxSize, maxMemoryMB, name = 'Cache') {
      this.cache = new Map();
      this.accessTimes = new Map();
      this.memorySizes = new Map();
      this.maxSize = maxSize;
      this.maxMemoryBytes = maxMemoryMB * 1024 * 1024;
      this.currentMemoryUsage = 0;
      this.name = name;
      this.stats = {
        hits: 0,
        misses: 0,
        evictions: 0,
        sets: 0
      };
    }

    set(key, value, estimatedSizeKB = 10) {
      const sizeBytes = estimatedSizeKB * 1024;
      
      // Remove existing entry if present
      if (this.cache.has(key)) {
        this.currentMemoryUsage -= this.memorySizes.get(key) || 0;
      }
      
      // Memory eviction if needed
      if (this.currentMemoryUsage + sizeBytes > this.maxMemoryBytes) {
        this._evictMemory(sizeBytes);
      }
      
      // Size eviction if needed
      if (this.cache.size >= this.maxSize) {
        this._evictLRU();
      }
      
      // Set new entry
      this.cache.set(key, value);
      this.accessTimes.set(key, Date.now());
      this.memorySizes.set(key, sizeBytes);
      this.currentMemoryUsage += sizeBytes;
      this.stats.sets++;
      
      this._log(`SET: ${key}, Memory: ${(this.currentMemoryUsage / 1024 / 1024).toFixed(1)}MB`);
    }

    get(key) {
      if (this.cache.has(key)) {
        this.accessTimes.set(key, Date.now());
        this.stats.hits++;
        this._log(`HIT: ${key}`);
        
        // Update global counter
        if (window.DorikState) {
          window.DorikState.counters.cacheHits++;
        }
        
        return this.cache.get(key);
      }
      
      this.stats.misses++;
      this._log(`MISS: ${key}`);
      
      // Update global counter
      if (window.DorikState) {
        window.DorikState.counters.cacheMisses++;
      }
      
      return null;
    }

    has(key) {
      return this.cache.has(key);
    }

    delete(key) {
      if (this.cache.has(key)) {
        this._remove(key);
        return true;
      }
      return false;
    }

    clear() {
      this.cache.clear();
      this.accessTimes.clear();
      this.memorySizes.clear();
      this.currentMemoryUsage = 0;
      this._log('CLEARED');
    }

    _evictLRU() {
      let oldestKey = null;
      let oldestTime = Date.now();
      
      this.accessTimes.forEach((time, key) => {
        if (time < oldestTime) {
          oldestTime = time;
          oldestKey = key;
        }
      });
      
      if (oldestKey) {
        this._remove(oldestKey);
        this.stats.evictions++;
        this._log(`LRU Evicted: ${oldestKey}`);
      }
    }

    _evictMemory(neededBytes) {
      let evicted = 0;
      while (this.currentMemoryUsage + neededBytes > this.maxMemoryBytes && this.cache.size > 0) {
        this._evictLRU();
        evicted++;
      }
      if (evicted > 0) {
        this._log(`Memory evicted ${evicted} entries`);
      }
    }

    _remove(key) {
      this.cache.delete(key);
      this.accessTimes.delete(key);
      const size = this.memorySizes.get(key) || 0;
      this.memorySizes.delete(key);
      this.currentMemoryUsage -= size;
    }

    getStats() {
      const hitRate = this.stats.hits + this.stats.misses > 0 
        ? ((this.stats.hits / (this.stats.hits + this.stats.misses)) * 100).toFixed(1)
        : '0';
      
      return {
        name: this.name,
        size: this.cache.size,
        maxSize: this.maxSize,
        memoryMB: (this.currentMemoryUsage / 1024 / 1024).toFixed(1),
        maxMemoryMB: (this.maxMemoryBytes / 1024 / 1024).toFixed(1),
        hitRate: hitRate + '%',
        hits: this.stats.hits,
        misses: this.stats.misses,
        evictions: this.stats.evictions,
        sets: this.stats.sets
      };
    }

    _log(message) {
      if (window.DorikUtils?.log) {
        window.DorikUtils.log(`[${this.name}]`, message);
      }
    }
  }

  // === IMAGE PRELOADER SYSTEM ===
  class ImagePreloader {
    constructor() {
      this.loadedImages = new Set();
      this.loadingPromises = new Map();
      this.failedImages = new Set();
    }

    preload(url, priority = 'low') {
      if (this.loadedImages.has(url)) {
        return Promise.resolve();
      }

      if (this.failedImages.has(url)) {
        return Promise.reject(new Error(`Previously failed: ${url}`));
      }

      if (this.loadingPromises.has(url)) {
        return this.loadingPromises.get(url);
      }

      const promise = new Promise((resolve, reject) => {
        const img = new Image();
        
        // Set loading priority if supported
        if ('loading' in img) {
          img.loading = priority === 'high' ? 'eager' : 'lazy';
        }
        
        // Add crossorigin for CORS
        img.crossOrigin = 'anonymous';
        
        img.onload = () => {
          this.loadedImages.add(url);
          this.loadingPromises.delete(url);
          this._log(`‚úÖ Image loaded: ${url}`);
          resolve(img);
        };
        
        img.onerror = () => {
          this.failedImages.add(url);
          this.loadingPromises.delete(url);
          this._log(`‚ùå Image failed: ${url}`);
          reject(new Error(`Failed to load image: ${url}`));
        };
        
        img.src = url;
      });

      this.loadingPromises.set(url, promise);
      return promise;
    }

    preloadBatch(urls, priority = 'low', batchSize = 5) {
      if (!Array.isArray(urls) || urls.length === 0) {
        return Promise.resolve();
      }

      const batches = [];
      for (let i = 0; i < urls.length; i += batchSize) {
        batches.push(urls.slice(i, i + batchSize));
      }

      return batches.reduce((promise, batch) => {
        return promise.then(() => {
          const batchPromises = batch.map(url => 
            this.preload(url, priority).catch(err => {
              this._log('Image preload failed:', url, err.message);
              return null;
            })
          );
          return Promise.all(batchPromises);
        });
      }, Promise.resolve());
    }

    isLoaded(url) {
      return this.loadedImages.has(url);
    }

    isFailed(url) {
      return this.failedImages.has(url);
    }

    getStats() {
      return {
        loaded: this.loadedImages.size,
        failed: this.failedImages.size,
        loading: this.loadingPromises.size
      };
    }

    clear() {
      this.loadedImages.clear();
      this.loadingPromises.clear();
      this.failedImages.clear();
    }

    _log(...args) {
      if (window.DorikUtils?.log) {
        window.DorikUtils.log('[ImagePreloader]', ...args);
      }
    }
  }

  // === CACHE MANAGER ===
  window.DorikCache = {
    
    productCache: null,
    imageCache: null,
    imagePreloader: null,
    cleanupTimer: null,

    // Initialize cache system
    init() {
      const config = window.DorikConfig;
      if (!config) {
        console.error('‚ùå DorikConfig not found! Load config.min.js first');
        return false;
      }

      // Create cache instances
      this.productCache = new SmartCache(
        config.MAX_PRODUCT_CACHE, 
        config.MAX_MEMORY_MB * 0.7, 
        'ProductCache'
      );
      
      this.imageCache = new SmartCache(
        config.MAX_IMAGE_CACHE, 
        config.MAX_MEMORY_MB * 0.3, 
        'ImageCache'
      );

      // Create preloader
      this.imagePreloader = new ImagePreloader();

      // Setup cleanup timer
      this.setupCleanup();

      window.DorikUtils?.log('‚úÖ Cache system initialized');
      return true;
    },

    // Setup automatic cleanup
    setupCleanup() {
      const config = window.DorikConfig;
      if (config.CLEANUP_INTERVAL > 0) {
        this.cleanupTimer = setInterval(() => {
          this.performMaintenance();
        }, config.CLEANUP_INTERVAL);
        
        // Store timer reference in global state
        if (window.DorikState) {
          window.DorikState.timers.cleanup = this.cleanupTimer;
        }
      }
    },

    // Perform cache maintenance
    performMaintenance() {
      const memoryInfo = window.DorikUtils?.getMemoryInfo();
      if (memoryInfo) {
        window.DorikUtils?.log(`Memory: ${memoryInfo.used_mb}MB / ${memoryInfo.total_mb}MB / ${memoryInfo.limit_mb}MB`);
        
        // Aggressive cleanup if memory usage is high
        if (memoryInfo.used_mb > memoryInfo.limit_mb * 0.8) {
          this.forceCleanup();
        }
      }

      // Log cache stats
      if (window.DorikConfig?.DEBUG) {
        console.table([
          this.productCache.getStats(),
          this.imageCache.getStats()
        ]);
      }
    },

    // Force cleanup when memory is low
    forceCleanup() {
      const beforeProduct = this.productCache.cache.size;
      const beforeImage = this.imageCache.cache.size;
      
      // Clear old entries (keep only recent 50%)
      this._cleanupOldEntries(this.productCache, 0.5);
      this._cleanupOldEntries(this.imageCache, 0.5);
      
      const afterProduct = this.productCache.cache.size;
      const afterImage = this.imageCache.cache.size;
      
      window.DorikUtils?.log(`üßπ Force cleanup: Products ${beforeProduct}‚Üí${afterProduct}, Images ${beforeImage}‚Üí${afterImage}`);
    },

    _cleanupOldEntries(cache, keepRatio) {
      const entries = Array.from(cache.accessTimes.entries());
      entries.sort((a, b) => b[1] - a[1]); // Sort by access time (newest first)
      
      const keepCount = Math.floor(entries.length * keepRatio);
      
      for (let i = keepCount; i < entries.length; i++) {
        cache.delete(entries[i][0]);
      }
    },

    // Product cache methods
    setProduct(containerId, data) {
      if (!this.productCache) {
        window.DorikUtils?.error('Product cache not initialized');
        return;
      }
      
      const size = JSON.stringify(data).length / 1024; // Estimate size in KB
      this.productCache.set(containerId, data, size);
    },

    getProduct(containerId) {
      if (!this.productCache) {
        return null;
      }
      
      return this.productCache.get(containerId);
    },

    hasProduct(containerId) {
      return this.productCache?.has(containerId) || false;
    },

    // Image cache methods
    setImage(url, data) {
      if (!this.imageCache) {
        return;
      }
      
      const size = data.length ? data.length / 1024 : 10; // Estimate size
      this.imageCache.set(url, data, size);
    },

    getImage(url) {
      return this.imageCache?.get(url) || null;
    },

    hasImage(url) {
      return this.imageCache?.has(url) || false;
    },

    // Preloading methods
    preloadImage(url, priority = 'low') {
      if (!this.imagePreloader) {
        return Promise.reject(new Error('Image preloader not initialized'));
      }
      
      return this.imagePreloader.preload(url, priority);
    },

    preloadImages(urls, priority = 'low') {
      if (!this.imagePreloader) {
        return Promise.reject(new Error('Image preloader not initialized'));
      }
      
      const deviceInfo = window.DorikState?.deviceInfo;
      const batchSize = deviceInfo?.isHighPerf ? 8 : 
                      deviceInfo?.isMobile ? 3 : 5;
      
      return this.imagePreloader.preloadBatch(urls, priority, batchSize);
    },

    // Get comprehensive stats
    getStats() {
      const stats = {
        productCache: this.productCache?.getStats() || null,
        imageCache: this.imageCache?.getStats() || null,
        imagePreloader: this.imagePreloader?.getStats() || null,
        globalCounters: window.DorikState?.counters || null,
        memoryInfo: window.DorikUtils?.getMemoryInfo() || null
      };
      
      return stats;
    },

    // Export cache data
    exportData() {
      const exportData = {
        timestamp: new Date().toISOString(),
        products: {},
        images: {},
        stats: this.getStats()
      };
      
      // Export product cache
      if (this.productCache) {
        this.productCache.cache.forEach((value, key) => {
          exportData.products[key] = value;
        });
      }
      
      // Export image cache keys (not actual data due to size)
      if (this.imageCache) {
        this.imageCache.cache.forEach((value, key) => {
          exportData.images[key] = 'cached';
        });
      }
      
      return exportData;
    },

    // Import cache data
    importData(data) {
      if (!data || typeof data !== 'object') {
        window.DorikUtils?.error('Invalid import data');
        return false;
      }
      
      try {
        // Import products
        if (data.products && this.productCache) {
          Object.entries(data.products).forEach(([key, value]) => {
            this.setProduct(key, value);
          });
        }
        
        window.DorikUtils?.log('‚úÖ Cache data imported');
        return true;
        
      } catch (error) {
        window.DorikUtils?.error('Cache import failed:', error);
        return false;
      }
    },

    // Cleanup methods
    clear() {
      this.productCache?.clear();
      this.imageCache?.clear();
      this.imagePreloader?.clear();
      
      if (this.cleanupTimer) {
        clearInterval(this.cleanupTimer);
        this.cleanupTimer = null;
      }
      
      if (window.DorikState?.timers.cleanup) {
        clearInterval(window.DorikState.timers.cleanup);
        window.DorikState.timers.cleanup = null;
      }
      
      window.DorikUtils?.log('üßπ Cache system cleared');
    }
  };

  window.DorikUtils?.log('‚úÖ Cache module loaded');

})();
