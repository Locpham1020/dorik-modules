/**
 * CACHE.MIN.JS - Smart Cache System
 * LRU cache vá»›i memory management cho products & images
 */

(function() {
  'use strict';

  // === SMART CACHE CLASS ===
  class SmartCache {
    constructor(maxSize, maxMemoryMB, name = 'Cache') {
      this.cache = new Map();
      this.accessTimes = new Map();
      this.memorySizes = new Map();
      this.maxSize = maxSize;
      this.maxMemoryBytes = maxMemoryMB * 1024 * 1024;
      this.currentMemoryUsage = 0;
      this.name = name;
      this.stats = {
        hits: 0,
        misses: 0,
        evictions: 0,
        sets: 0
      };
    }

    set(key, value, estimatedSizeKB = 10) {
      const sizeBytes = estimatedSizeKB * 1024;
      
      // Remove existing entry if present
      if (this.cache.has(key)) {
        this.currentMemoryUsage -= this.memorySizes.get(key) || 0;
      }
      
      // Memory eviction if needed
      if (this.currentMemoryUsage + sizeBytes > this.maxMemoryBytes) {
        this._evictMemory(sizeBytes);
      }
      
      // Size eviction if needed
      if (this.cache.size >= this.maxSize) {
        this._evictLRU();
      }
      
      // Set new entry
      this.cache.set(key, value);
      this.accessTimes.set(key, Date.now());
      this.memorySizes.set(key, sizeBytes);
      this.currentMemoryUsage += sizeBytes;
      this.stats.sets++;
      
      this._log(`SET: ${key}, Memory: ${(this.currentMemoryUsage / 1024 / 1024).toFixed(1)}MB`);
    }

    get(key) {
      if (this.cache.has(key)) {
        this.accessTimes.set(key, Date.now());
        this.stats.hits++;
        this._log(`HIT: ${key}`);
        return this.cache.get(key);
      }
      
      this.stats.misses++;
      this._log(`MISS: ${key}`);
      return null;
    }

    has(key) {
      return this.cache.has(key);
    }

    delete(key) {
      if (this.cache.has(key)) {
        this._remove(key);
        return true;
      }
      return false;
    }

    clear() {
      this.cache.clear();
      this.accessTimes.clear();
      this.memorySizes.clear();
      this.currentMemoryUsage = 0;
      this._log('CLEARED');
    }

    _evictLRU() {
      let oldestKey = null;
      let oldestTime = Date.now();
      
      this.accessTimes.forEach((time, key) => {
        if (time < oldestTime) {
          oldestTime = time;
          oldestKey = key;
        }
      });
      
      if (oldestKey) {
        this._remove(oldestKey);
        this.stats.evictions++;
        this._log(`LRU Evicted: ${oldestKey}`);
      }
    }

    _evictMemory(neededBytes) {
      let evicted = 0;
      while (this.currentMemoryUsage + neededBytes > this.maxMemoryBytes && this.cache.size > 0) {
        this._evictLRU();
        evicted++;
      }
      if (evicted > 0) {
        this._log(`Memory evicted ${evicted} entries`);
      }
    }

    _remove(key) {
      this.cache.delete(key);
      this.accessTimes.delete(key);
      const size = this.memorySizes.get(key) || 0;
      this.memorySizes.delete(key);
      this.currentMemoryUsage -= size;
    }

    getStats() {
      const hitRate = this.stats.hits + this.stats.misses > 0 
        ? ((this.stats.hits / (this.stats.hits + this.stats.misses)) * 100).toFixed(1)
        : '0';
      
      return {
        name: this.name,
        size: this.cache.size,
        maxSize: this.maxSize,
        memoryMB: (this.currentMemoryUsage / 1024 / 1024).toFixed(1),
        maxMemoryMB: (this.maxMemoryBytes / 1024 / 1024).toFixed(1),
        hitRate: hitRate + '%',
        hits: this.stats.hits,
        misses: this.stats.misses,
        evictions: this.stats.evictions,
        sets: this.stats.sets
      };
    }

    _log(message) {
      if (window.DorikConfig?.DEBUG) {
        console.log(`[${this.name}]`, message);
      }
    }
  }

  // === PRELOADER SYSTEM ===
  class ImagePreloader {
    constructor() {
      this.loadedImages = new Set();
      this.loadingPromises = new Map();
    }

    preload(url, priority = 'low') {
      if (this.loadedImages.has(url)) {
        return Promise.resolve();
      }

      if (this.loadingPromises.has(url)) {
        return this.loadingPromises.get(url);
      }

      const promise = new Promise((resolve, reject) => {
        const img = new Image();
        
        // Set loading priority if supported
        if ('loading' in img) {
          img.loading = priority === 'high' ? 'eager' : 'lazy';
        }
        
        img.onload = () => {
          this.loadedImages.add(url);
          this.loadingPromises.delete(url);
          resolve(img);
        };
        
        img.onerror = () => {
          this.loadingPromises.delete(url);
          reject(new Error(`Failed to load image: ${url}`));
        };
        
        img.src = url;
      });

      this.loadingPromises.set(url, promise);
      return promise;
    }

    preloadBatch(urls, priority = 'low', batchSize = 5) {
      const batches = [];
      for (let i = 0; i < urls.length; i += batchSize) {
        batches.push(urls.slice(i, i + batchSize));
      }

      return batches.reduce((promise, batch) => {
        return promise.then(() => {
          const batchPromises = batch.map(url => 
            this.preload(url, priority).catch(err => {
              console.warn('Image preload failed:', url, err);
              return null;
            })
          );
          return Promise.all(batchPromises);
        });
      }, Promise.resolve());
    }

    isLoaded(url) {
      return this.loadedImages.has(url);
    }

    clear() {
      this.loadedImages.clear();
      this.loadingPromises.clear();
    }
  }

  // === CACHE MANAGER ===
  window.DorikCache = {
    
    // Initialize caches
    init() {
      const config = window.DorikConfig;
      if (!config) {
        console.error('DorikConfig not found! Load config.min.js first');
        return false;
      }

      // Create cache instances
      this.productCache = new SmartCache(
        config.MAX_PRODUCT_CACHE, 
        config.MAX_MEMORY_MB * 0.7, 
        'ProductCache'
      );
      
      this.imageCache = new SmartCache(
        config.MAX_IMAGE_CACHE, 
        config.MAX_MEMORY_MB * 0.3, 
        'ImageCache'
      );

      // Create preloader
      this.imagePreloader = new ImagePreloader();

      // Setup cleanup timer
      this.setupCleanup();

      window.DorikUtils?.log('âœ… Cache system initialized');
      return true;
    },

    // Setup automatic cleanup
    setupCleanup() {
      const config = window.DorikConfig;
      if (config.CLEANUP_INTERVAL > 0) {
        window.DorikState.timers.cleanup = setInterval(() => {
          this.performMaintenance();
        }, config.CLEANUP_INTERVAL);
      }
    },

    // Perform cache maintenance
    performMaintenance() {
      const memoryInfo = performance.memory;
      if (memoryInfo) {
        const usedMB = memoryInfo.usedJSHeapSize / 1024 / 1024;
        const totalMB = memoryInfo.totalJSHeapSize / 1024 / 1024;
        const limitMB = memoryInfo.jsHeapSizeLimit / 1024 / 1024;
        
        window.DorikUtils?.log(`Memory: ${usedMB.toFixed(1)}MB / ${totalMB.toFixed(1)}MB / ${limitMB.toFixed(1)}MB`);
        
        // Aggressive cleanup if memory usage is high
        if (usedMB > limitMB * 0.8) {
          this.forceCleanup();
        }
      }

      // Log cache stats
      if (window.DorikConfig?.DEBUG) {
        console.table([
          this.productCache.getStats(),
          this.imageCache.getStats()
        ]);
      }
    },

    // Force cleanup when memory is low
    forceCleanup() {
      const beforeProduct = this.productCache.cache.size;
      const beforeImage = this.imageCache.cache.size;
      
      // Clear old entries (keep only recent 50%)
      this._cleanupOldEntries(this.productCache, 0.5);
      this._cleanupOldEntries(this.imageCache, 0.5);
      
      const afterProduct = this.productCache.cache.size;
      const afterImage = this.imageCache.cache.size;
      
      window.DorikUtils?.log(`Force cleanup: Products ${beforeProduct}â†’${afterProduct}, Images ${beforeImage}â†’${afterImage}`);
    },

    _cleanupOldEntries(cache, keepRatio) {
      const entries = Array.from(cache.accessTimes.entries());
      entries.sort((a, b) => b[1] - a[1]); // Sort by access time (newest first)
      
      const keepCount = Math.floor(entries.length * keepRatio);
      const removeCount = entries.length - keepCount;
      
      for (let i = keepCount; i < entries.length; i++) {
        cache.delete(entries[i][0]);
      }
    },

    // Product cache methods
    setProduct(containerId, data) {
      const size = JSON.stringify(data).length / 1024; // Estimate size in KB
      this.productCache.set(containerId, data, size);
      
      // Update global counter
      if (window.DorikState) {
        window.DorikState.counters.cacheHits++;
      }
    },

    getProduct(containerId) {
      const data = this.productCache.get(containerId);
      if (!data && window.DorikState) {
        window.DorikState.counters.cacheMisses++;
      }
      return data;
    },

    hasProduct(containerId) {
      return this.productCache.has(containerId);
    },

    // Image cache methods
    setImage(url, data) {
      const size = data.length ? data.length / 1024 : 10; // Estimate size
      this.imageCache.set(url, data, size);
    },

    getImage(url) {
      return this.imageCache.get(url);
    },

    hasImage(url) {
      return this.imageCache.has(url);
    },

    // Preloading methods
    preloadImage(url, priority = 'low') {
      return this.imagePreloader.preload(url, priority);
    },

    preloadImages(urls, priority = 'low') {
      const deviceInfo = window.DorikState?.deviceInfo;
      const batchSize = deviceInfo?.isHighPerf ? 8 : 
                      deviceInfo?.isMobile ? 3 : 5;
      
      return this.imagePreloader.preloadBatch(urls, priority, batchSize);
    },

    // Cleanup methods
    clear() {
      this.productCache?.clear();
      this.imageCache?.clear();
      this.imagePreloader?.clear();
      
      if (window.DorikState?.timers.cleanup) {
        clearInterval(window.DorikState.timers.cleanup);
        window.DorikState.timers.cleanup = null;
      }
      
      window.DorikUtils?.log('ðŸ§¹ Cache cleared');
    }
  };

  window.DorikUtils?.log('âœ… Cache module loaded');

})();
